---
title: "3.2 システム構造"
slug: "32-システム構造"
hidden: false
createdAt: "2019-09-17T07:58:48.931Z"
updatedAt: "2019-09-18T09:34:52.121Z"
---
[block:api-header]
{
  "title": "チェーンシステムと相互運用可能な実行環境"
}
[/block]

[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/d715058-image025.png",
        "image025.png",
        1133,
        599,
        "#385273"
      ],
      "caption": "Cocosチェーンのゲーム/アプリの実行環境構造"
    }
  ]
}
[/block]
**マルチチェーンシステムと互換性のあるゲーム実行環境**

Cocos-BCXは今後ブロックチェーンゲームの実行環境は以下の特徴を持っていると考えています：
・完全なブロックチェーンの相互運用可能なインターフェィス
・透明の下方への継承関係
・アトミック化された不可分操作
・マルチプラットフォームとの互換性

開発コストを削減するため、Cocos-BCXは様々なAPPに適用する統合開発環境及びインターフェィスをデザインしました。COCOS　Creatorと組合せ、ゲームプログラムとブロックチェーンとのコネクトプロセスを簡素化することによって、チェーンシステムとのインタラクションを透明にします。ブロックチェーン知識のない開発者も障害なくブロックチェーンゲームを開発できます。

Cocos-BCXチェーンシステムのSDKはCocosエンジンのRuntimeに統合され、完全なチェーンシステムと相互運用が可能なインターフェィスを提供します。開発者はCocos-BCX　SDKを利用して、ゲームをブロックチェーンネットワークへコネクトすることができます。インタラクションプロセスが透明化、構造化になるため、開発チームはマルチブロックチェーンネットワークとデバイスとの互換性を考えせずに済みます。

一方、実行環境はAndroid、iOS、PC　Web、HTML５など様々なプラットフォームと互換性を持っているため、異なるプラットフォームで実行できます。
[block:api-header]
{
  "title": "チェーンシステムのインタラクティブ・インターフェイス"
}
[/block]
Cocos-BCXはマルチチェーンシステムと相互運用が可能な開発環境を開発者に提供します。

Cocos-BCXの開発環境はAndroid、iOSシステムに適用するSDK、フロントエンドwebアプリに適用するjavascript、バックエンドアプリに適用するpython、PHPなどのコンポーネントを提供します。

開発者はこれらの開発環境を利用して独自にdAppsを開発し、新規登録、アカウント情報とアセット、ゲームデータの操作などのデータインタラクションができます。また、ユーザーはオンチェーンで代替可能や代替不可能なデジタルアセットデータを保存することもできます。それから、互換性やオーダー可能性に優れるサービスを提供しているため、チェーンシステムはアセットデータを平文でストレージすることを強要しません。よって、開発者はデータが安全にクライアント端末とマーケットプラグインの解析を行うよう、データ構造を柔軟にデザインできます。

現在、チェーンシステムの開発環境は主に代替可能/不可能なデジタルアセットとアイテムの照会、トランザクション、所有権変更、タスク作成、提議及び表決など、機能のパッケージを提供しています。
[block:api-header]
{
  "title": "マルチブロックチェーンとコネクトするゲートウェイ"
}
[/block]
Cocos-BCXでは、代替可能/不可能なアセットとスマートコントラクトは分けられています。今後オンチェーンではタスクが大量、継続的に発生することが予測できます。そのため、なるべくアセットの解析と流通コストを減らして、アセットのクロスチェーンがよりスムーズ且つ安全に進行できます。
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/216e35a-image027.png",
        "image027.png",
        801,
        526,
        "#f7f9fa"
      ]
    }
  ]
}
[/block]
Cocos-BCXはコインやアイテムに用いる自動取引（Exchange）ツールを提供し、統一した価値評価システムの下でゲーム間、プラットフォーム間コンテンツの移行が滑らかに行われます。

**デジタルアセットの交換（Exchange）**

ゲーム内デジタルアセットとERC20規格のアセットとの交換は：

[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/482209c-image029.png",
        "image029.png",
        939,
        211,
        "#f5f5f5"
      ]
    }
  ]
}
[/block]
ゲートウェイを利用してゲーム内のコインも他のチェーンシステム（コンソーシアム/プライベート）と交換、取引できます。

ゲーム内代替不可能なアセットとERC721規格のアセットとの交換：
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/a5ed106-image031.png",
        "image031.png",
        939,
        198,
        "#f3f3f3"
      ]
    }
  ]
}
[/block]
BCX-NHAS-1808は分散型台帳ネットワーク（DLT）向けの代替不可能なデジタルアセット（以下NHアセットと略称する）規格です。アセットとコントラクトが分離している、拡張可能とカスタム可能なデータ構造などの特性を持っているため、ERC721など他のNHアセット規格との互換性があります。
ERC875とERC721はイーサリアムのNHアセット規格です。その中、ERC721は初めて誕生したNHアセット規格で、それをベースにして改良されたのはERC841とERC821です；ERC875の関数はname、symbol、balanceO、transfer、transferFrom、totalSupply、ownerOfとtradeだけで、ERC721と比べてより簡単なので、ERC721のシンプルバージョンと言っても良いです。
今後ERC721、ERC875、BCX-NHAS-1808をはじめとした複合型NHアセットをサポートするよう、ゲートウェイをさらに改善します。アイテムやNHアセットにとって、ゲートウェイは専用コンパイラーの役割を担っています。構造化データを翻訳、交換することで、NHアセットとアイテムとの相互交換ができるだけでなく、多くのアイテム（オンチェーン/オフチェーン）との互換性を持っているため、ゲーム性とUXが一層向上できます。
[block:api-header]
{
  "title": "既存チェーンシステムへの最適化と拡張"
}
[/block]
**改善されたNHアセットデータ構造**

NHアセットは一つのDLT向けのデジタルアセットであり、アセットは唯一性を持っています。そのデータ構造を改良し、ブロックチェーンゲームへのサービスがより柔軟性が溢れます。
発生可能なゲームデータと拡張データを受容するため、BCXはデータ構造をデザインし直して、カスタムデータフィールドを追加しました。一方、新なデータ構造に合わせて、合意、証人、ブロック生成などの重要プロセスも調整しました。ブロックデータが膨大にならないよう、アイテムの生成と属性変更時だけブロックデータに記録し、通常タスクとトランザクションの場合ではハッシュポインターのみ記録します。
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/e3dcbf2-image033.png",
        "image033.png",
        939,
        714,
        "#eaebed"
      ]
    }
  ]
}
[/block]
チェーンネットワークで、NHアセットのデータ構造は固定データゾーンと拡張データゾーンに分けられています。その内、固定データゾーンはアセットID、世界観と基本データゾーンを含め、NHアセットの基本情報をストレージします。アセットID、即ちアセットがDLTネットワークで唯一の標識であり、アクセス、照会、修正される時の唯一証拠です；世界観は世界観IDと当該アセットが有効になり、適用するゲーム、世界、及び流通するためのトークン類型を含めています；基本データゾーンはアセットの基本情報、作成時間、作成者、所有者、使用者、使用権限ホワイトリスト・ブラックリストなどが含まれている。
拡張データゾーンはNHアセットの属性拡張をサポートし、組合せ関係データとゾーンデータがあります。組合せ関係データはアセットの組合せ関係や従属関係を説明するデータであり、一単位をゾーンとし、世界観で適用できるビジネスモデルデータのストレージゾーンです。ゲームごと、ビジネスモデルごとにゾーン標識やデータゾーンをもっていて、各データゾーンが分離しています。各ゾーンはいくつか専用のコントラクトがり、データがゾーン標識とキー値ペアの形でストレージされ、攻撃、防御、耐力など数値を表現します。
それから、使用権と所有権が分けられたデザインによって、権限システムに基づく賃貸、抵当、担保など複雑なビジネスモデルが実行可能になります。
既存イーサリアムNHアセット規格とBCX-NHAS-1808の相違について、図表で説明します。
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/7b8f96c-image035.png",
        "image035.png",
        932,
        378,
        "#b1c7d3"
      ]
    }
  ]
}
[/block]
**分離したアセットとコントラクトのデータ保存**

代替可能、代替不可能なアセットとスマートコントラクトのデータはオンチェーンで別々にストレージされます。

Cocosのチェーンネットワークでは、タスクが大量且つ継続的に発生するため、出来る限りにアセット解析やトランザクションのコストを減らす必要があります。アセットをコントラクトと分離させることで、コントラクトの個別解析・実行が実現できます。

アセットとコントラクトデータストレージの分離というデザインによって、アセット権限は全て所有者にあり、アセットに対する操作は所有者の授権がなければ執行できません。それに、コントラクトという要素の制約を除外する場合、NHアセットのクロスチェーンがより容易に実現できるので、データ分離したデザインはセキュリティが高いと言えます。

**改良されたDPoSコンセンサスメカニズム**

Cocos-BCXテストチェーンはコンセンサスレイヤーでDPoSアルゴリズムを利用しています。

DPoSアルゴリズムは証人と要求された時間枠を予測することでブロックプロヂューサーと生成時間を推定します。従来時間枠の間隔は５秒に対して、より速いネットワークブロードキャスト速度と処理速度を得るため、間隔を3秒に設定します。万が一ネットワークまたはデバイスハードウェアの故障などでブロックが生成していない場合、予測の証人が要求された時間枠内に機能しても、ブロック生成はしません。新しい証人がデリゲートされてから、次の時間枠内にブロックを生成します。
Cocos-BCXの予測証人が理事会メンバーによって選出されます。予測証人は通称アクティブ証人で、普通11人から21人からなっています。DPoSアルゴリズムの下で、どのアクティブ証人も同じブロックの生成確率を持っていて、インセンティブとの一致性も保証できます。グラフェンベースの投票は24時間ごとにアップデートするに対し、セキュリティ、安定性、公平性を向上するため、初期では12時間以下に設定します。
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/525e7a1-image037.png",
        "image037.png",
        853,
        328,
        "#aab9cb"
      ],
      "caption": "既存コンセンサスメカニズム比較"
    }
  ]
}
[/block]
DPoSアルゴリズに基づき、メインチェーン上のアクティブ証人の数は常にサイドチェーンより多いため、メインチェーンのブロックは常にサイドチェーンより高いです。一方、ユニバーサル投票は投票集中も回避でき、ネットワークセキュリティが保証されます。既存コンセンサスメカニズムの比較は上図を参照してください。

**現代暗号学によるセキュリティ対策**

現代暗号学技術は数学の原理に基づく暗号術であり、現在すでに広くインターネット分野に応用されています。よく見られる対称暗号技術はWi-Fiに使われているAES暗号化技術および非対称暗号化アルゴリズム（公開鍵暗号システム）RSA、ECなどを含めている。その中で、ECC（楕円曲線暗号アルゴリズム）はブロックチェーン領域でよく使用されている暗号化アルゴリズムである。こちらのアルゴリズムは、数学原理に基づく復号計算が不可能な暗号化システムを構築しています。膨大なデータを解析するため、正しい秘密鍵がない限り、時間がかなりかかり（百年の可能性もあり）、実現価値がなくなります。
ECCとは、Elliptic curve cryptographyであり、1985年にNeal Koblitz とVictor Millerがそれぞれ定義しています。

**低フォークリスク**

ビットコインとイーサリアムのProof-of-Workメカニズムでは、マイナーは同じメカニズムに従っています。二人のマイナーはブロックを同時に生成したら、フォークが発生しました。「最長チェーンのルール」のメカニズムでは、フォークしたチェーンは6ブロックを経つと、短い方が放棄されます。しかし、マイナーが異なるメカニズムに従うと、ソフトフォークとハードフォークという二つの結果になります。ソフトフォークとハードフォークは相対で、ブロックチェーンシステムの古いバージョンと新しいバージョンとの違いとも言えます。元システムをアップデートすると、ソフトフォークがなくなります；それに対して、ハードフォークは同じメインチェーン上でマイナーが異なるコンセンサスメカニズムに基づきブロック生成すると、一つのチェーンが二つのチェーンに分けられます。2016年7月の「The　DAO」事件は最も有名なイーサリアムネットワークハードフォークのケースです。イーサリアムがイーサリアムとイーサリアムオリジナルとしてフォークしてから、元メインチェーンの処理速度は低下になり、進んで全メインチェーンネットワークセキュリティに重大な影響を及ぼしています。
Cocos-BCXはDPoSコンセンサスメカニズムを利用し、マイナーによってブロック生成する必要がなくなります。そして中央計算力がメインチェーンへの影響が回避できるため、フォークするリスクが低くなります。DPoSメカニズムの下で、証人が投票でフォークを起こす場合、1／3以上の証人が同時にメカニズムを違反しないとフォークしません。一方、ユーザーも投票でアクティブ証人を除去して、フォークする可能性を軽減することができます。ビットコインとイーサリアムのProof-of-Workメカニズムでの高フォークリスクと比べ、Cocos-BCXのフォークリスクが低く、開発者とユーザーのデータセキュリティも保証できます。

**マルチチェーンとの相互運用性**

Cocos-BCXはマルチチェーンの交換ゲートウェイ以外、マルチチェーンとの相互運用性も提供します。例えば、次のフェーズでのアップデートは、IPFS上のコントラクトとデータのストレージをサポートできるようにします。

**アトミック性のため複数操作を合併する**

ブロックチェーンゲームでアイテムの作成はアトミック操作です。アイテム作成者はプレーヤーのニーズや提供した材料やアセットによって、アイテムを作って、完了後プレーヤーに渡します。プロセス内の全ての操作（OP）結果を一致するため、デジタル資産の作成、アイテム属性の設定、資産所有権をユーザーへの変更など、一つのトランザクション、つまりアトミック操作に合併して、全操作が同時成功か同時失敗になります。
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/7ec5020-image039.png",
        "image039.png",
        940,
        509,
        "#dbdde0"
      ]
    }
  ]
}
[/block]
アトミック操作のアプリケーション例を挙げれば、Project　BCXの仲介者のいない資産トランザクションがあります。売り手の利益を増やし、買い手のコストを減らすのが目的です。仲介者のいない流通プラットフォーム自体はユーザーのアセットデータを保存せず、ピアツーピアのリクエストの仲人の役割だけ担います。ゲーム会社はゲームアセットのデータ構造を自由にデザインできます。代替可能なアセットだけでなく、アイテム、装備、プレーデータなど代替不可能なアセットも流通できるようになります。ユーザーがゲームコンテンツ流通プラットフォームでリクエストを送信して、対応するアセット（トークン、アイテムなど）がロックになり、リクエストをキャンセルするまで、使用できません。入札者のメインチェーンIDとアセット情報を含んでいるリクエストが完了になると、システムが自動的に資産所有権の変更を行い、そして落札者が支払ったアセットを入札者に移行してから、トランザクションリクエストが完了です。
アセットのトランザクション操作が実行させると、入札／落札をリクエストとしてプラットフォームへ送信し、支払った代替可能なアセットデータと代替不可能なアセットの所有権変更は一つ不可分操作としますい。つまり二つの操作がコンセンサスに承認される必要があります。どちらか一つの動作がメインチェーンに却下されたら、全取引がロールバックされます。即ち、トランザクションプロセスにおけるアセットの所有権変更または代替可能なアセット移行は一つの取引にまとめられ、動作状態が一致し、取引完了後照会できる唯一の取引IDが作成されます。
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/38e3bdc-image041.png",
        "image041.png",
        939,
        277,
        "#dde5f1"
      ]
    }
  ]
}
[/block]

[block:api-header]
{
  "title": "BCXテストネット：ハイパフォーマンスのチェーンネットワークとコントラクト仮想マシン"
}
[/block]
Cocos-BCXは十分な並列処理能力を持っています。
既存大部分のオンラインゲームにとって、ユーザーの規模が一定の程度に達すると、短時間内で大量なデータを処理するサーバが必要ですが、既存イーサネットでは実現できません。
Cocos-BCXは改良されたDPoSコンセンサスを利用し、理論スループットは約100,000トランザクション／秒に達しています。合理的なデータコントロールモードでは、並列処理性能が既存ゲームの開発と通常実行をサポートできます。それに、大型オンラインゲームの需要にも大体満足でき、ゲームエクスペリエンスが既存中央型ゲームとほぼ変わらないことが保証できます。
大規模のオンラインゲームの場合、データインタラクションが頻繫に起こっています。例えば、DNFの同時オンラインユーザーが60万にも達し、Steamでは1420万人というすさまじい数まで達したこともあります。ユーザーのデータ伝送行為ごとをコンセンサスへのアクセスリクエストと見做すと、Cocos-BCXの最大スループットでもこのレベルのリクエストをサポートできない可能性があります。そのため、開発チームは立会（Witness）の優先順位によって、証人デリゲートテンプレート（Delegation　Templates）をデザインしました。一つの証人は実行中の操作を全部立ち会う・処理するのではなく、いつくか同じタイプの操作だけに立ち会って、ブロック生成を記録します。その上、このモデルでは、異なるゲームデータの伝送／立会も非同期的に実行されます。そして、ゲームによって最適なデリゲートテンプレートを採用し、オンチェーンのデータベースサービスがデータを検証します。つまり、ユーザーはオンチェーンでデータを検証、保存します。このプロセスは効率が高く、大規模のゲームシーンでデータ操作をサポートできます。
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/644ef35-image043.png",
        "image043.png",
        939,
        406,
        "#eeeeee"
      ]
    }
  ]
}
[/block]
コントラクトは自己実行可能なプログラムです。同時、システムの参加者として、環境の基本ルール（コンパイラルール）に従って既定タスクを実行したり、入力と出力を定義したり、価値を受け入れ、保存したり、情報や価値を伝送したりができます。スマートコントラクトは「トラストレス」を前提し、ノードは互いに信頼しません。ブロックチェーン分散型ストレージという特徴から、オンチェーン上どのノードも同じ実行コードを記録します。実行結果はネットワークの計算力に立ち会われて、ユニバーサル投票で承認されます。また、Cocos-BCXのコントラクトは証人デリゲートを定義できます。
ユーザーによいゲームエクスペリエンスを提供できるよう、Cocos-BCXはLUA言語を基づきゲームシーン向けのハイパフォーマンスコントラクト仮想マシン方案をデザインし直しました。既存のコントラクト仮想マシンと違って、既存ブロックチェーン実行環境とコントラクト仮想マシンの実行効率をカスタマイズし、最適化しました。その上、Cocos-BCXの仮想マシンはゲームSDKと同じ言語やAPIシステムを使用し、チェーンとゲーム執行環境のインタラクションインターフェィスも提供しています。よって、ブロックチェーンコントラクトが単一で、柔軟性とカスタム可能性が欠く現状は徹底的に変わっていきます。スマートコントラクトのユースケースはトークンに限らず、基本ルール、キャラクター、シナリオ、マップなどゲームと直接関係しているコンテンツも適用できます。
[block:api-header]
{
  "title": "オンチェーンゲーム向け分散型台帳システムへ強化"
}
[/block]
上述したように、オンチェーンゲームはゲーム全体ロジックのオンチェーン実行を最終目標としていますが、既存ブロックチェーン技術ではまだまだサポートできません。課題は：
・ノード同期のデータ量とコスト
フルノードだけがコントラクトを実行できるが、ネットワークで発生したデータを全部記録するため、データ量の膨大さが一目でわかります。それに、ノードを新規作成してデータの同期にかかる時間もすさまじいほどです。
・大型コントラクトをサポート
オンチェーンでのゲームロジックを実現するには、コントラクトがゲーム全体のバックグラウンドロジックを含む必要があります。通常のブロックサイズより大きくなる恐れはあるが、既存ブロックチェーン技術ではブロックサイズを超えるコントラクトの実行が不可能です。
・コントラクトの継続的な執行
ゲームロジックのオンチェーン実行とはゲームが終了するまで、コントラクトが継続的に執行するということです。つまりゲームコントラクトの実行時間は常にブロック生成周期より長く、クロスブロックで執行しますが、既存ブロックチェーン技術はこのような実行モードに対応していません。
・取引実行のレイテンシ
ゲームロジックのオンチェーン実行は、ゲーム内全ての操作がオンチェーンで処理されることになります。ですが、その中高速応答の取引に対して、従来の応答速度はブロック生成で決められ、ブロック生成周期の制限があるため、最も速いスピードでもコントラクトの即時応答の要求を満足できません。
・ランダムプロセスへの合意ができない
オンチェーンのランダムプロセスルールはスマートコントラクトで描述されます。コントラクトはプロセスを公開するため、第三者に予測されないランダム結果を導くには、コントラクトの実行プロセスにノードノイズが参加する必要があります。しかし、異なるノードのノイズが一致していません。つまり、他のノードがそのコントラクトを実行することでランダムプロセスの結果の正しさを検証することが不可能になり、合意もできません。
・オンチェーンでタイマーとハートビートの実現
タイマーとハートビートはオンチェーンで全てのコントラクト、ゲームコンテンツの定時実行、自動実行、条件付き実行を実現する条件です。ただし、既存ブロックチェーン技術はまだ必要となる同期、同期のセキュリティなどをサポートできません。
・デジタルアセット権限
従来のデザインだと、デジタルアセットはコントラクトのデータゾーンに記録されます。コントラクトと独立できないため、コントラクトの所有者はデジタルアセットデータまで修正でき、アセット所有者に損失をもたらす恐れがあります。
上記課題について、Cocos-BCXは既存分散型台帳システムをさらに改善し、オンチェーンでゲームを実行するのを目指して、下記提案をしました。
・データ量とコストを削減
・コンセンサスプロセスへのシンタックスサポート
・コントラクトの継続的な執行
・取引の低レイテンシ実行
・オンチェーンでの信頼性できるランダムプロセス
・オンチェーンでタイマーとハートビートを実現
・NHアセットのデータ構造で権限デザインを追加

**Light　Node**

Cocos-BCXでは、Light　Node（以下ライトノードと称する）の本質はチェーンと相互運用が可能な環境です。フルノードと違って、ライトノードはオンチェーンでの全てのデータではなく、必要なコントラクトとコンテキストデータのみ同期します。そのため、ノード同期のデータ量と時間が大幅に減り、メモリーと時間コストから言うと、オンチェーンゲームの実現は可能になります。
Cocos-BCXのゲームはコントラクトとして、ライトノード環境でローカル実行をします。コントラクトで合意が必要な部分はいくつかの子コントラクトに分けられ、関連するノードに送信し、合意されます（詳細は「コンセンサスプロセスへのシンタックスサポート」節を参照）。このデザインを通して、大型のゲームコントラクトも効率的で、ほぼレイテンシがなく実行できます。一方、コントラクトの合意と非合意部分を分けて処理することで、ユーザーエクスペリエンスを保障し、既存ブロックチェーンと同じ信頼できるデータも入手できます。それに、ライトノードへの検証はプロセスと結果への検証ではなく、ノード実行環境と入力データへの検証（TEEへの検証）なので、実行効率をさらに向上させます。

**コントラクトの継続的な実行**

ライトノードを通して、ゲーム全体をコントラクトとして実行する仮想が可能になります。ローカル実行のゲームコントラクトも長期的、継続的にライトノードで実行できます。実行プロセスはブロック生成周期かブロックサイズに制限されず、ゲームコントラクトで合意必要のある子コントラクトのみに関係あります。
ゲームコントラクトと子コントラクトはシンタックスレベルで合意への優先順位によって、継続的に実行するとともにキーステップへの検証や同期を完成し、ゲームコントラクト継続的な実行及び結果を合意で検証するメカニズムを実現していきます。

**セッションメカニズム**

オンチェーンではセッションを作成するインターフェィスを提供します。このインターフェィスはコントラクトのパブリックデータゾーンで有効制限の持つユーザーセッションリストを作成できます。ユーザーは同じセッション内のユーザーにリクエストをプッシュするができ、他のユーザーが通知を受け、即時にデータをアップデートします。

**コンセンサスプロセスへのシンタックスサポート**

Cocos-BCXはコンセンサスプロセスへのシンタックスサポートを提案しました。特定のキーワードをもってスクリプトへの合意に優先順位をつけることで、コンセンサスインタープリタが全文をスキャンする際、合意の必要があると表記するコントラクトを子コントラクトとして抽出し、チェーンネットワークでの関連するノードまで送信して合意します。合意の優先順位は合意しない、通常合意、即時応答、即時確認などが含まれています。
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/28f7951-image045.png",
        "image045.png",
        830,
        826,
        "#f2f3f4"
      ]
    }
  ]
}
[/block]
コントラクト全体はローカル実行し、合意の必要がある部分なら、シンタックス優先順位によって合意します。コントラクトによって異なる合意ステップを採用するので、ゲームコントラクトの実行がよりスムーズになり、つまり待ちが低くなります。
即時確認は優先順位が最も高く、コントラクトの実行プロセスと合意プロセスは二つの非同期プロセスです；即時応答の子コントラクトについて、トランザクションを送信すると、ノードが即時に送信されたフィードバック、即ち取引ハッシュ（Tx　ID）をリターンします；通常合意の子コントラクトはチェーン上トランザクションの実行プロセスに従います；合意しない子コントラクトはライトノードのみで実行します。
また、合意の必要がある部分は子コントラクトとして抽出され、別々に実行されますが、他のノードでも正確な結果を得るように、それらの子コントラクトコンテンツは完全なコンテキストと余分な依存関係のないデザインをしました。

**コントラクト合意の優先順位**

Cocos-BCXはゲームで合意の必要があるトランザクションをオンチェーンで処理します。ですが、その中高速応答の取引に対して、従来の応答速度はブロック生成で決められ、ブロック生成周期の制限があるため、最も速いスピードでもコントラクトの即時応答の要求を満足できません。

・トランザクションの高速な非同期確認
コントラクトはシンタックスレベルでトランザクションへの合意をサポートします。コントラクトを実行する際、即時確認のトランザクションを直ちに抽出して、ブロードキャストします。そして、ノードに受取ったらすぐプロセスを実行し、結果をブロードキャストします。同時に、ブロック生成周期内のブロックプロデューサーはブロードキャストされた結果をリザルトプールにストレージします。同じ結果の数が既定閾値に達すると、ブロックプロデューサーは即時トランザクションをブロードキャストし、結果を確認してから、トランザクションをブロックキャッシュに書き込みます。
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/5efadd3-image047.png",
        "image047.png",
        940,
        1022,
        "#ecf1f3"
      ]
    }
  ]
}
[/block]
このデザインでは、ノードが即座に取引を送信、処理、ブロードキャストをします。ブロック生成と取引の実行プロセス操作は非同期に行うため、トランザクションの高速な非同期確認ができます。
・即時応答
Cocos-BCXでは、即時応答のコントラクトについて、ユーザーはノードにトランザクションのリクエストをすると、ノードが即座にブロードキャストすると同時に、ユーザーに取引ハッシュをリターンします。このデザインでは、トランザクションの完了時は従来のとはほとんど変わらないが、応答にはほぼ遅延が発生しないでの、応答速度を大幅に向上させます。
さらに、ユーザーは取引ハッシュでトランザクションを追跡できます。一方、トランザクションデータもユーザーの操作履歴リストへアップデートしてから、ダイナミックにユーザーにプッシュします。よって、ユーザーはチェーンネットワークがトランザクションを検証、応用した後のコールバックを待たずに済みます。Cocos-BCXはイーサリアムのハッシュトレース特性に倣った上に、ユーザータスクダイナミックなプッシュのメカニズムも利用したからです。

**極小のトランザクションレイテンシ**

従来のブロックチェーンシステムの場合、トランザクションの実行を確認するプロセスはノードがブロックデータを受信し、トランザクションデータを解析・実行し、正しい結果を確認し、書き込まれたデータで完了になります。一つのトランザクションがリクエストすると、pendingリストに入り、次のブロック生成周期が来るまで実行しません。そのため、チェーンシステムはトランザクションへの高速応答、処理ができないことがよく見られます。
・合意の優先順位
Cocos-BCXはトランザクションの合意に対して、シンタックスレベルでの優先順位をつけました。即時確認のトランザクションの場合、ノードが直ちにトランザクションを送信、処理、ブロードキャストします。ブロック生成と取引実行の操作は非同期に行われ、トランザクションへの高速な非同期確認が可能です；また、このモデルでは即時応答のトランザクションについての遅延はほぼありません。ノードが即時にトランザクションのリクエストを送信するので、応答速度を大幅に向上させます。
・分割された立会
さらにノードの使用率と処理効率を向上させるため、Cocos-BCXはデリゲート立会のベースで、分割された立会のデザインをしました。つまり、いくつのノードが集中して特定のコントラクトリクエストのみ処理します。原理が下図のようです。
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/1d77f3e-image049.png",
        "image049.png",
        939,
        416,
        "#f4f3f3"
      ]
    }
  ]
}
[/block]
ゲーム業界にとって、分割された立会は異なるリクエストに対し、関連ノードの処理能力を最適化できます。例えば、浮動小数点演算が集中される場合でコア計算力を強化したり、構造化データの処理が集中される場合でストレージIO機能を強化したりすることで、全体の処理効率や最大収益が実現できます。

**デリゲート型のトランザクションメカニズム**

デリゲート型トランザクションは主にランダム性の高く、ノードによって実行結果が異なるトランザクション（例：ランダム数の生成）を処理します。しかし、このようなトランザクションはユーザーデータが含まないリクエストのみ適用します。コントラクト内のコンセンサス識別子は、コンセンサへの参加をデリゲートする必要のあるノードクラスタ（ノードセット）名を定義し、処理するノードをアサインすることを可能にします。必要ノードが１だと（N＝１）、指定ノードクラスタがランダムに現在アクティブなセットを選びだし、トランザクションを処理するようにアサインします（例：ランダム事件の処理など）；ノード数が１より大きい場合（N＞１）、いくつか指定ノードによって処理します。信頼できる実行環境（TEE）からクリアしたデリゲートはデリゲート型トランザクションを受信し、実行可能性を検証してから実行します。そして、実行結果を暗号化し、パッケージしてオンチェーンでブロードキャストします。
デリゲートされたノードクラスタを指定するデザインを採用した理由は二つあります。一つ目はセキュリティです。デリゲートノードクラスタだけを指定し、クラスタ内のノードはランダムに処理するので、デリゲートは具体的なノード情報を入手できなくて、不正行為が防止できます；二つ目は実行可能性です。指定されたノードクラスタは受信する時アクティブノードが存在するのを保証できます。
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/9db9826-image051.png",
        "image051.png",
        939,
        634,
        "#f6f5f6"
      ]
    }
  ]
}
[/block]
**信頼できるランダムプロセスをオンチェーンで実装**

外部ランダムとは、ランダム要因はチェーンシステム外にあることを指しています。それに対して、内部ランダムではランダム要因がチェーンシステム内にあります。外部ランダムはランダム要因の生成プロセスはチェーンシステムに信用されるのを保証できないため、オンチェーンでランダムプロセスを実装するのは、ランダムプロセスと結果の信頼性という課題を解決することです。
・不正行為を防ぐため、ランダムプロセスを実行したノードにランダムデータの応用シーンや対象に知らせてはなりません；
・公平のため、コールしたトランザクションが操作終了まで、ランダムプロセスを公開してはなりません（例：トランプゲームの中でのプレーたちのカード情報）；
・BP/開発者の不正行為を防止できます。
現在、Cocos-BCXはすでにランダムプロセスをオンチェーンで実装し、インターフェイスでコールできるようになっています。一般開発のように、コントラクトでrandom関数をコールすれば内部で生成したランダムデータを入手できます。
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/8b7a4ac-image053.png",
        "image053.png",
        940,
        200,
        "#f0f1f2"
      ]
    }
  ]
}
[/block]
**オンチェーンの信頼できるランダムプロセス**

オンチェーンでのブロックチェーンゲームルールは実用価値があるかどうかは、オンチェーンでランダムプロセスの実現に深く関係しています。それを実現するには、以下の課題を解決する必要があります。オンチェーンのランダムプロセスルールはスマートコントラクトで描述されます。コントラクトはプロセスを公開するため、第三者に予測されないランダム結果を導くには、コントラクトの実行プロセスにノードノイズが参加する必要があります。しかし、異なるノードのノイズが一致していません。つまり、他のノードがそのコントラクトを実行することでランダムプロセスの結果の正しさを検証することが不可能になり、合意もできません。
この課題について、我々は三つの解決策を提案します：
一
・ブロックチェーンのダイナミックデータセット内に、いくつかのランダムデータプールを作成します。そこでBP（ブロックプロデューサー）がクローズドソースの暗号化手順で暗号化したデータフィールドにランダムな結果をパッケージ化します。ノードの全てが同じランダムデータプールを保持します。データプールがパイプラインでパッケージされ、ReadとWriteのパッケージを持っています。ルールに適用するRead・Writeのアクセスのみができ、先入れ先出しの順序で出力されます。
・ブロックチェーンで全てのノードはトランザクション処理が一致しているため、アプリはランダムプロセス、結果をクエリするなら、プールからの読み込みが可能です。このメカニズムでは、プロセスと結果のセキュリティはブロックチェーンがランダムプロセスへの要求を満たせます：
▪すべてのR／W操作は不可逆的にランダムプールを変更します；
▪ランダムデータの入力は、クローズドソースのダイナミックな暗号化ライブラリによって行われます；
▪生成者はランダム結果のアドレスや、ユースケースを事前に知ることができません；
この解決策はチェーンネットワークがトランザクション処理の手順と一致している場面に適用します。例えば、RPGゲームでユーザーがマップで宝箱をゲットしてランダムアイテムを獲得するプロセスです。
二
・デリゲートメカニズムを通して、一部のトランザクシを信頼できるノードクラスタまでデリゲートし、処理することができます。ノードクラスタはオンラインで信頼できるノードをランダムに指定し、実行させます。終了後実行結果を記録し、ブロードキャストまたはポーリングメカニズムを通してデリゲートへ送信します。
この解決策はオンチェーンのデリゲートメカニズムに基づいているため、チェーンに対する修正は案一より少ないが、実現を可能にするには、以下の要件を満たす必要があります：
▪デリゲート側はTEEに検証され、自身の信頼性を保証します；
▪デリゲート側によりランダムプロセスを実行し、結果を発表する時も、同じくセキュリティを採用した暗号化ライブラリによって完成します；
▪デリゲート側が受信したデータは偽造でないことを確保するため、暗号化されたデータの伝送は「ゼロ知識証明」あるいは他の方法によって身分を証明した上、デリゲート側に識別されます。
この提案はタスクが複数の参加者を持つにも関わらず、同じランダム結果を望んでいるユースケースに適用します。例えば、トランプゲームでのシャッフルです。
三
目前のBPはランダムのトランザクションを受信して、ランダム関数をコールし、結果を生成します。そして、プロセスと結果を暗号化し、ブロックデータに書き込んでから、オンチェーンネットワークにパッケージします。他のノードはその結果を以て応用し、ランダムタトランザクションの合意が完了になります。
この方案は既に実現していて、サイコロ、くじ引きのようなユースケースに適用します。

**タイマーとハートビート**

ほぼすべてのゲームとアプリにはオンラインに検出される必要があります。Cocos-BCXはブロックチェーンゲームをデザインする際、ユーザーの状態チェックと継続的なセッションを解決するため、タイマーとハートビートを提案しました。
時刻同期メカニズムはチェーンネットワークでタイマーを実現する前提です。しかし、従来の時刻同期メカニズムは外部の時刻シグナルまたは信頼性のあるサービスを頼っています。それに対して、ブロックチェーンはトラストレスなので、外部も他のサービスも信頼性の自己証明ができなくなります。そのため、オンチェーン時間はシステム内でのみ設定できます。
Cocos-BCXが提案したのは：ブロックのタイムスタンプを利用して、ノードがブロックを生成するのが日時のブロードキャストになります。各ノードがブロックデータを受信し、日時を同期します。最終的に、オンチェーンネットは一つのブロック周期内日時の同期プロセスが完成します。
このデザインに基づいて、我々は二つの解決策を提出します：
・ブロック生成時間を最低単位にして、既定のタイマーゴールで動作します。ブロックデータのタイマースタンプを基準にするため、タイムゾーンなどにも影響されません。オンチェーンでは統一される時間標準とみなし、チェーンネットワークとタイムゾーンでランダムに同じタイムルールで正常実行できます。
・信頼できる内部ランダムプロセスと類似している情報伝送メカニズムを利用し、タイマーの関数をデリゲートでノードに送信します。また、タイマーの初期化と期限通知などはノードの実現レイヤーで実行します。
ハートビートはタイマーと類似していて、パルス時間はブロックのタイムスランプに従います。一つのハートビート周期で、ノード／端末は常にアップデートし、情報を送信します。もしアップデートがされなかったら、ノード/端末が切断となります。これで、タイマーとハートビートはユーザーの状態チェックと今後のセッションメカニズムの応用が可能になります。

**標準化されたNHアセット**

NHアセットの拡張データゾーンはアセットの属性拡張をサポートし、アセットが適用する世界観内におけるゲームの具体的なトランザクションデータを保存します。NHアセットで拡張データ構造のデザインは柔軟性に満ちていて、ゲームまたはその他のトランザクションの拡張ができます。経験したゲームに従って、アセットがゲーム間でトランザクションする度にゾーンデータも当然増加します。データ量が膨大になるとチェーンの実行効率にも影響を及ぼします。一方、悪意のコントラクトによって大量なデータが書き込まれ、データの冗長化にもなります。それを回避するため、アセット権限のコンセプトを追加しました：
・ユーザーには、アセットの特定ゾーンデータを修正する権限ではなく、削除する権限を持たせることで、データの冗長化を減らすと同時に、チートプログラムなどの不正行為も防止できます； 
・拡張データゾーンのデータを全て読み込むのが可能ですが、修正はコントラクトと対応するゾーンデータのみです。例えば、ブロックチェーンゲームでは、コントラクトで「ヒーローズ・オブ・ザ・ストーム」「ワールド・オブ・ウォークラフト」のアセットデータを読み込むことができます。ですが、「ヒーローズ・オブ・ザ・ストーム」のアイテムAは「ワールド・オブ・ウォークラフト」にワープし、アイテムBに破壊された場合、「ヒーローズ・オブ・ザ・ストーム」では破壊されません。

**既定ルールに従うデザインツール**

実際、ゲーム世界ではこのような出来事がありました。プレイヤーはゲームに共感し、プレーを決めました。ですが、ゲーム開始前、開発者は私利のためコントラクコードを改ざんし、ルールを変更したり、ファンディング資金を別に転用し、ゲームサービスを終了したりしました。これらいずれもユーザーの財産に損失を与えるに違いません。既定ルールに従ってツールのデザインはこれらを避けるためです。ゲーム開発者はユーザーの信頼性を得るため、ブロックチェーンゲームの既定ルールに従うデザインツールを利用し、ゲームを設計することができます。開発する際、スマートコントラクトは一定の代替可能なアセットをロックし、アンロックの条件、時間と金額も同時設定します。コントラクトコードにアセットロック期間でルールを変更できない関数を追加することで、この期間ではコントラクトコードが改ざんできなくなるため、ゲームは最初設定したルールに従って進行していきます。

**BP/開発者の不正行為を防止する認証メカニズム**

BPはチェーンネットワークでトランザクション処理と通信のコアノードとして、一般ノードを先んじて直近の処理結果を入手できます。しかし、適時情報あるいは機密情報について、BPは情報入手から不正行為を行う恐れがあります。例えば、ランダムプロセスの結果を事前に知り、コントラクトで実行結果を予測するなど、紛れもなく不公正で、不安全です。
ここで論及した開発者は、一般開発者とコントラクト開発者など、ある程度でチェーン相互運用／改造能力の持つ個人または組織を含んでいます。これらの開発者はオンチェーンデータの解析／改ざんができます。そしてコードの読み取りなどを通して、伝送過程における使用可能な暗号化／隠避通信技術ディテールを知り、さらにコードを書き、違法で情報（ランダムプロセス、機密情報データなど）を入手することもできます。
よって、BCXはBPと開発者の不正行為を防止するためのトランザクション実行、情報送信、実行メカニズムを提案しました。続いて簡単な説明に入ります。

**暗号化されたダイナミック伝送**

ブロードキャストした機密情報の監視、解析を防ぐため、BCXのチェーンネットワークではセキュリティの暗号化されたダイナミック通信を利用します。

[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/4ee4a93-image055.png",
        "image055.png",
        939,
        530,
        "#f8f9fa"
      ]
    }
  ]
}
[/block]
ランダムシードの生成を例にすると、あるランダムシードが生成され、プロデューサーはタイマー、ブロックサイズ、ノイズなどダイナミックな情報をAES秘密鍵で暗号化し、暗号化された情報をブロードキャストします。全てのノードが同じダイナミックな秘密鍵の生成アルゴリズムを持っているので、シード情報を正しく解析できますが、違法で監視する第三者は解析できないため、伝送過程におけるセキュリティが保証できます。

**カスタムノードがネットワークへのアクセスを防止する**

情報伝送にセキュリティをかけるだけでは、ノード開発者がプログラムを修正して情報の出力、復号が防止できないため、ここでは修正されたノードプログラムがチェーンネットワークへのアクセスを防止するための身分検証メカニズムをデザインしました。
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/d471ee1-image057.png",
        "image057.png",
        939,
        571,
        "#f9f9fa"
      ]
    }
  ]
}
[/block]
BCXはノードプログラムをリリースした時、オープンソースコードに含まれない且つバージョン番号と関連する検証情報をネストします。ノードがチェーンネットワークまたは他のノードへアクセスする際、チェーンネットワークで記録された検証情報との一致性を検証します。承認されないノードからのアクセスを拒否するので、修正されたノードプログラムからの不正行為が防止できます。また、二次開発者もソースコードの身分検証情報をカスタマイズして、非オフィシャルノードからのアクセスを防止する特性のある独自のチェーンネットワークをリリースすることが可能です。

**プロセス変数を隠す**

コントラクトはチューリング完全な状態マシンシステムなので、既定の入力は必ず既定の出力を獲得しまし。そして、トランザクションメカニズムに基づき、出力結果をチェーンネットワークにブロードキャストします。しかし、もしブロードキャストされた情報は操作の中間プロセスであれば、他人に知られてはならないプロセス変数が公開されるおそれがあります。よって、Cocos-BCXは図のように、プロセル変数を隠したコントラクトの実行ロジックを使用しました。
合理的なコントラクトデザインによって、機密情報に関連するプロセス変数を一つの操作（OP）にまとめて実行します。実行プロセスは実行ノード内で完成するため、最終ブロードキャストされるのは操作結果のみで、プロセス変数が隠されて、公開されるリスクがなくなります。
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/59473a1-image059.png",
        "image059.png",
        940,
        609,
        "#fafbfc"
      ]
    }
  ]
}
[/block]
**実行認証付きのコントラクトメカニズム**

開発者が悪意を持ってコントラクトインターフェィスをコールし、実行結果を予測することを防止するため、コントラクトシステムに身分認証メカニズムを追加しました。つまり権限のあるアカウントだけはコントラクトの指定インターフェィスを実行できます。
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/b9c1ffa-image061.png",
        "image061.png",
        939,
        526,
        "#fafafa"
      ]
    }
  ]
}
[/block]
コントラクトは実行リクエストを受信したら、リクエスト内の署名情報をコントラクトが指定した実行者権限と照合し、承認された実行者のリクエストのみがコントラクト関数を実行できます。でなければすぐコントラクトを終了し、リクエスト者が支払った費用も返還しません。このメカニズムでは、開発者はチェーンとコントラクトのコード、実行プロセルと原理がわかるとしても、悪意を持って特定のインターフェィスをコールすることができないので、実行結果を予測できません。

**機密プロセスをオンチェーンの信頼できる環境で実行する**
一定の期間に継続的に発生する機密情報または操作（トランプゲームなど）について、実行ロジックをTEE（Trusted Execution Environment、信頼できる実行環境）メカニズムの保障の下で、ブラックボックスモードで実行をします。環境の信頼性を保証するため、チェーンネットワークはいつもTEEメカニズムを通して、ブラックボックスに周期性のチャレンジ／検証を行います。それから、継続的に発生する機密プロセスを実行する際、ランダムに一つの環境を選んでから執行します。チェーンネットワークデータの公正、公開、透明のため、実行完了後、実行プロセスがバックトレースされるに十分な記録データと結果データをオンチェーンに送信します。
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/0ec7823-image063.png",
        "image063.png",
        939,
        323,
        "#f5f6f6"
      ]
    }
  ]
}
[/block]
このメカニズムによって、開発者もBPもブラックボックス内の実行プロセスに参加できないので、不正行為が回避できます。総じて、上記保障デザインによって、Cocos-BCXは信頼性やセキュリティのある実行環境で全ての操作プロセスをサポートできるようになります。