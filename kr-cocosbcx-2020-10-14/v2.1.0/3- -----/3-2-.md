---
title: "3.2 시스템 아키텍쳐"
slug: "3-2-"
hidden: false
createdAt: "2019-08-26T04:48:34.423Z"
updatedAt: "2019-08-26T05:02:01.754Z"
---
## 블록체인 게임을 위한 통합 인터랙티브 런타임 환경
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/fdddf61-6aa4721-3-2-1Cocos-BCX.png",
        "6aa4721-3-2-1Cocos-BCX.png",
        1133,
        599,
        "#385273"
      ],
      "caption": "3-2-1 Cocos-BCX On-Chain 게임 런타임 환경 아키텍처"
    }
  ]
}
[/block]
** 다중 시스템 호환성을 갖춘 게임 런타임 환경 **

Cocos-BCX는 미래의 블록 체인 게임의 런타임 환경에 다음 기능이 포함되어야한다고 생각합니다.
  * 완전한 블록 체인 상호 운용 가능한 인터페이스;
  * 투명한 하향 상속;
  * 패키지 원자 연산;
  * 여러 운영 체제와 호환됩니다.

개발 프로세스를 단순화하기 위해 Cocos-BCX는 다양한 앱을위한 통합 런타임 환경을 설계하고 상호 운용 가능한 인터페이스를 지원합니다. COCOS Creator와 결합하여 게임 프로그램과 블록 체인 간의 연결을 단순화하여 개발자와의 상호 작용을 투명하게 만들어 기존 게임 개발자가 장애물없이 블록 체인 게임을 개발하거나 마이그레이션 할 수 있도록합니다.

Cocos-BCX SDK는 Cocos Runtime에 통합되어 게임을위한 완벽한 블록 체인 대화식 인터페이스를 제공합니다. 개발자는 투명하고 구조화 된 상호 작용을 위해 Cocos-BCX SDK 기반의 게임 콘텐츠를 블록 체인 네트워크에 연결할 수 있으므로 게임 개발 팀이 R & D에 투자하여 블록 체인 네트워크 및 다른 장치와 호환되지 않도록 할 수 있습니다.

런타임 환경은 Android, iOS 및 PC 웹, 모바일 H5 및 기타 시스템 및 환경과 호환됩니다. 런타임 환경의 게임은 다른 플랫폼에서 실행될 수 있습니다.


## 대화식의 인터랙티브 인터페이스

Cocos-BCX는 개발자가 블록 체인과 쉽게 상호 작용할 수있는 상호 운용 가능한 환경을 제공합니다.

Cocos-BCX 블록 체인 인터페이스는 Android, iOS, 프론트 엔드 웹 애플리케이션 용 JavaScript, 백엔드 Python 및 PHP를 포함한 멀티 시스템 SDK와 통합됩니다.

이러한 개발 환경은 블록 체인 소프트웨어의 개발 및 계정 등록, 사용자 정보, 자산 운영 및 사용자 데이터 운영과 같은 데이터 상호 작용을 촉진 할 수 있습니다. 온 체인 데이터 인터페이스를 통해 사용자는 호환성 및 사용자 정의 기능이있는 동종 또는 동종이 아닌 자산 데이터를 저장할 수 있습니다. 블록 체인 시스템은 명확한 디지털 자산 텍스트를 요구하지 않습니다. 게임 개발자는 온 체인 데이터 스토리지를 구축 할 수있는 유연성이 뛰어나고 클라이언트 및 마켓 플러그인 파서에서 안전하게 전송할 수있는 정보를 보장합니다.

현재 블록 체인 대화 형 환경은 주로 동종 및 비 동종 자산 및 소품의 검색 및 전송, 소유권 변경, 거래 제출, 제안 및 투표를 포함한 기능의 패키징을 제공합니다.


## 대체가능, 대체 불가능한 자산 및 체인간 거래를 지원하는 Exchange 게이트웨이

동종 및 비 동종 자산은 Cocos-BCX의 스마트 계약과 분리됩니다. Cocos-BCX 네트워크에는 많은 수의 지속적인 트랜잭션이있을 것으로 예상됩니다. 비균질 자산의 교차 체인 교환을 달성하기 위해서는 자산 분석 및 유통 비용을 가능한 많이 줄여야합니다. 자산과 계약의 분리가보다 안전한 설계임이 입증되었습니다.
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/6cdb29b-b312f92-3-2-2.png",
        "b312f92-3-2-2.png",
        801,
        526,
        "#f7f9fa"
      ],
      "caption": "3-2-2 Exchange 게이트웨이"
    }
  ]
}
[/block]
Cocos-BCX는 코인과 소품의 자동 교환을위한 일련의 게이트웨이를 제공하여 통합 된 가치 시스템 하에서 다양한 온 체인 게임 및 플랫폼간에 콘텐츠를 원활하게 전송할 수 있습니다. 교환 할 수있는 내용에는 게임 코인, 장비 데이터 등이 포함됩니다.

** 디지털 게임 자산 교환 **

게임 디지털 자산과 이더 리움 ERC20 디지털 자산의 교환은 다음과 같습니다.
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/5c22f96-06e5cdb-_1.png",
        "06e5cdb-_1.png",
        939,
        211,
        "#f5f5f5"
      ],
      "caption": "3-2-3 ERC20 디지털자산의 교환"
    }
  ]
}
[/block]
게임 코인은 교환 게이트웨이를 통해 컨소시엄 체인과 개인 체인으로 이전 될 수 있습니다.

** 대체 불가능한 디지털 게임 자산 교환 **
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/e0941f9-2c0ecd3-_1.png",
        "2c0ecd3-_1.png",
        939,
        198,
        "#f3f3f3"
      ],
      "caption": "3-2-4 Cocos-BCX와 ERC721 디지털 자산의 교환"
    }
  ]
}
[/block]
BCX-NHAS-1808은 COCOS 토큰을 사용하는 분산 및 분산 원장 네트워크에 대한 비균질 디지털 자산 표준입니다. 비균질 자산에 대한 다른 표준과 호환되는이 제품은 자산과 계약 간의 분리 및 확장 가능하고 사용자 정의 가능한 데이터 영역이 특징입니다.

ERC875 및 ERC721 표준은 비균질 디지털 자산에 대한 이더 리움의 표준 프로토콜입니다. 어느 정도까지는 ERC875 표준은 가장 단순한 ERC721 표준의 업그레이드 버전과 비슷합니다. ERC841 및 ERC821 표준은 최적화되고 수정 된 버전이며 ERC875 표준은 더 단순하고 직접적입니다. 이름, 기호, balanceOf, transfer, transferFrom, totalSupply, ownerOf 및 trade를 포함한 정의 된 기능. ERC721 표준과 비교하여 ERC875 표준의 기능이 훨씬 간단합니다.

교환 게이트웨이에서 지원하는 디지털 자산 기술을 더욱 확장하면 게이트웨이는 ERC721, ERC875 및 BCX-NHAS-1808 표준으로 표시되는 비균질 복합 계약을 지원할 수 있습니다. 게이트웨이는 게임 소품과 균질하지 않은 계약을 교환 할 때 특정 컴파일러와 동일합니다. 구조화 된 데이터를 변환하고 교환함으로써 비균질 계약과 온 체인 게임 소품 간의 양방향 교환을 실현합니다. 체인 내부 및 외부에서 더 많은 유형의 소품 교환과 호환되므로 더 풍부한 게임 컨텐츠와 사용자 경험을 제공합니다.


## 기존 블록 체인 개선 및 확장
비균질 자산의 개선 된 데이터 구조 **
균질하지 않은 디지털 자산은 고유 자산 인스턴스가있는 분산 원장 네트워크에 적용되는 디지털 자산 유형입니다. 동종이 아닌 디지털 자산의 최적화 된 구조는 블록 체인 게임에보다 유연한 서비스를 제공합니다.

Cocos-BCX는 가능한 게임 데이터 및 확장 된 컨텐츠를 수용 할 수 있도록 데이터 구조를 재 설계하고 맞춤형 데이터 스토리지를 추가합니다. 한편 합의, 증인, 블록 생성 및 기타 중요한 프로세스는 새로운 데이터 구조와 일치하도록 조정됩니다. Cocos-BCX의 아이템 데이터는 생성 및 속성 변경의 경우에만 블록 데이터에 완전히 기록됩니다. 일반적인 트랜잭션 및 전송 중에는 트랜잭션 누적으로 블록 크기가 너무 빠르게 커지는 것을 방지하기 위해 해시 포인터 만 기록됩니다.
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/3b9a99a-b0ce604-_1.png",
        "b0ce604-_1.png",
        939,
        714,
        "#eaebed"
      ],
      "caption": "3-2-5 대체 불가능한 자산의 각 부분과 데이터 구조의 관계"
    }
  ]
}
[/block]
블록 체인 네트워크의 비균질 디지털 자산 데이터 구조는 고정 데이터 영역과 확장 가능한 데이터 영역으로 구분됩니다.

전자는 자산 ID, 세계 견해 진술 및 기본 데이터 영역을 포함하여 비균질 디지털 자산의 기본 정보를 저장합니다. 자산 ID는 분산 원장 네트워크에서 자산 인스턴스의 고유 식별자이며 자산을 액세스, 확인 및 수정하기위한 고유 자격 증명입니다. 월드 뷰 ID, 자산이 적용되고 지원되는 게임 유형, 세계 및 네트워크의 자산 순환을 지원하는 통화를 포함한 월드 뷰 진술. 기본 데이터 영역은 자산, 생산 시간, 생산자, 소유자, 사용자, 흑백 사용 권한 목록 등의 기본 설명을 포함한 정보로 구성됩니다.

확장 가능한 데이터 영역은 영역 데이터 및 조합 관계가있는 데이터를 포함하여 비균질 디지털 자산의 속성 확장을 위해 설계된 기능 섹션입니다. 조합 관계가있는 데이터는 자산 포트폴리오, 중첩 및 제휴를 설명합니다. 확장 가능한 데이터 영역은 지원되지 않는 월드 뷰의 특정 트랜잭션 데이터를 저장하며이 데이터 단위는 "영역"이라고합니다. 다른 게임이나 다른 비즈니스 엔터티는 영역 데이터 측면에서 독점 영역 ID와 데이터 영역을 가지며 서로 분리되어 있습니다. 영역 데이터는 공격, 방어 및 내구성과 같은 특정 게임의 데이터를 나타내는 영역 ID 및 데이터의 키-값 쌍의 형태로 저장됩니다.

또한, 분리 된 사용권 및 소유권의 설계는 온 체인 권한 시스템을 기반으로 임대, 모기지 및 서약을 포함한 복잡한 재무 모델의 비즈니스 설계를 가능하게합니다.

Cocos BCX-NHAS-1808은 자산과 계약의 분리, 확장 가능하고 사용자 정의 가능한 데이터 영역 및 기타 비 동종 자산 표준과의 호환성과 같은 이더 리움의 다른 비 동종 디지털 자산 표준에 비해 많은 이점이 있습니다.
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/5623f20-635f897-_1.png",
        "635f897-_1.png",
        932,
        378,
        "#b1c7d3"
      ],
      "caption": "3-2-6 기존의 대체 불가능 디지털 자산 표준간의 비교"
    }
  ]
}
[/block]
** 별도로 저장된 자산 및 계약 데이터 **

동종 및 비 동종 자산 데이터 및 스마트 계약은 블록 체인에 별도로 저장됩니다.

Cocos-BCX에는 많은 연속 트랜잭션이 있으므로 자산 분석 및 전송의 계산 비용을 줄여야합니다. 자산과 계약의 분리는 계약의 개별 실행 및 체인에 필요한 결과에 기여할 수 있습니다.

이 상황에서 자산 소유자는 자산에 대한 모든 권한을 가지며 자산의 작동은 소유자의 승인에 의해서만 가능합니다. 이런 방식으로 계약 속성을 수정하여 자산 속성을 파괴하거나 다른 사람의 자산을 호출하는 것을 피할 수 있습니다. 또한, 계약의 제약을 제거하는 것은 비균질 자산의 교차 체인 교환을 달성하는 데 도움이됩니다. 따라서 자산과 계약의 분리가보다 안전한 설계로 판명되었습니다.

** 개선 된 DPoS 합의 메커니즘 **
[block:image]
{
  "images": [
    {
      "image": []
    }
  ]
}
[/block]
Cocos-BCX TestNet의 합의 계층은 DPoS 합의 알고리즘을 채택합니다.

DPoS 알고리즘은 예약 된 감시 및 할당 된 시간 슬롯을 기반으로 블록 생성자와 블록 생성 시간을 유추합니다. 일반적으로 시간 슬롯 간격은 5 초입니다. 실제 응용 프로그램에서는 간격이 3 초로 설정되어 브로드 캐스트 속도가 빨라지고 처리량이 늘어납니다. 예약 된 감시가 할당 된 시간 슬롯에 도착했지만 네트워크 오류 또는 장비 오류로 인해 정상적인 생산이없는 경우 해당 시간 슬롯에서 블록이 생성되지 않습니다. 네트워크는 다음 시간 슬롯까지 기다린 후 다음 예정된 감시를 선택하여 블록을 생성합니다.

Cocos-BCX에서 이해 관계자는 투표를 통해 예정된 모든 증인을 선출합니다. 예약 된 증인은 집합 적으로 11에서 101 사이의 숫자를 가진 활성 증인이라고합니다. 이들은 DPoS 합의 알고리즘의 증인 예약 알고리즘에서 동일한 예약 된 블록 확률을 공유하여 블록 확률과 보상이 일관되게합니다. 그래 핀 투표는 일반적으로 24 시간마다 업데이트됩니다. 초기 단계에서 보안, 안정성 및 공정성을 위해 프로젝트 네트워크에 대한 투표는 일반적으로 12 시간 이하의 짧은 간격으로 업데이트되었습니다.
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/a88b9b0-e05878e-_1.png",
        "e05878e-_1.png",
        868,
        334,
        "#aab9cb"
      ],
      "caption": "3-2 기존의 합의 메커니즘 비교"
    }
  ]
}
[/block]
DPoS의 원칙에 따라 CocosChain은 증인과 시간 슬롯을 위임하여 블록 생산자와 생산 시간을 예측합니다. 메인 체인의 Aws는 항상 포크 체인의 Aws보다 큽니다. 결과적으로 메인 체인의 블록 높이는 포크 체인보다 높아야합니다. 범용 투표는 또한 증인의 중앙 집중화를 방지하고 네트워크 보안을 강화하기 위해 사용됩니다. 위의 [그림 3-2-7]은 서로 다른 감시 메커니즘 간의 비교를 보여줍니다.

** 발전된 암호화가 제공하는 보안 **
현대 수학 기반 암호화는 인터넷의 다양한 산업에 널리 사용되었습니다. 일반적인 대칭 암호화 기술에는 Wi-Fi에 사용되는 AES가 포함되며 비대칭 암호화 알고리즘에는 RSA (공개 및 개인 키 암호화) 및 ECC가 포함됩니다. 우리는 우리 플랫폼에서 ECC (Elliptic-curve cryptography)를 사용합니다. 이러한 알고리즘은 암호 해독 계산을 거부하는 암호화 및 암호 해독 시스템을 만듭니다. 키없이 암호화를 위반하려는 시도는 엄청난 시간 (약 100 년)이 걸리기 때문에 비실용적입니다.

타원 곡선 암호화로 완전히 명명 된 ECC는 1985 년에 Neal Koblitz와 Victor Miller가 각각 제안했습니다.

** 낮은 포크 위험 **
비트 코인과 이더 리움의 작업 증명 ( "PoW") 메커니즘 하에서 광부는 동시에 두 블록을 채굴 할 때 발생합니다. 더 짧은 블록 체인은 6 블록 후 "가장 긴 체인 규칙"에 의해 버려집니다. 그러나 광부가 동일한 메커니즘을 따르지 않으면 두 종류의 포크 (부드럽고 단단한)가 있습니다. 소프트 포크는 시스템 업그레이드에 의해 트리거되며 업그레이드가 완료 될 때까지 계속 존재합니다. 동일한 블록 메인 체인 시작에서 광부 그룹이 다른 합의 메커니즘을 취하는 경우 하드 포크가 발생하고 두 개의 개별 블록 체인이 형성됩니다. “DAO”는 2016 년 7 월 이더 리움 하드 포크의 유명한 사례입니다. 이더 리움이 이더 리움 및 이더 리움 클래식에 포크 할 때 원래 메인 체인에 해당하는 컴퓨팅 성능이 감소하여 보안의 보안에 중대한 영향을 미칩니다. 전체 메인 체인 네트워크.

게임 데이터의 안전성과 정확성을 보장하기 위해 CocosChain은 채굴없이 DPoS 컨센서스 메커니즘을 사용합니다. PoW에 비해 포크 위험이 낮습니다. 포크는 증인의 1/3 이상이 합의에 동의하지 않는 경우에만 발생할 수 있습니다. 투표를 통해 AW 제거시 포크를 방지 할 수도 있습니다.

** 멀티 체인 상호 운용성 **
플랫폼은 교차 체인 교환 게이트웨이 외에도 다중 체인 상호 운용성을 제공합니다. 예를 들어, Cocos-BCX는 다음 개발 단계에서 IPFS에 대한 대규모 스마트 계약 및 데이터 스토리지를 지원할 것입니다.

** 무결성을 보장하기위한 다중 작업 병합 **
블록 체인 게임을위한 소품 제작은 원자 적입니다. 소품 제작자는 플레이어가 제출 한 수요, 재료 및 자산을 기반으로 소품을 만듭니다. 완료되면 소품이 플레이어에게 전송됩니다. 이 프로세스에는 디지털 자산 생성, 소품 속성 설정 및 자산 소유권 이전을 포함하여 일련의 작업 (OP)이 사용됩니다. 운영 결과의 일관성을 보장하기 위해 작업을 하나의 트랜잭션, 즉 하나의 원자 작업으로 결합합니다. 이 경우 트랜잭션 내부의 모든 작업이 동시에 성공 또는 실패합니다.
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/478f46a-d776974-_1.png",
        "d776974-_1.png",
        940,
        509,
        "#dbdde0"
      ],
      "caption": "3-2-8 웑자적 합병의 운영"
    }
  ]
}
[/block]
원자 조합의 또 다른 적용은 판매자 BC 더 많은 구매자가 더 적게 소비하는 것을 돕기 위해 Project BCX의 중간 자산 교환입니다. 중개되지 않은 순환 플랫폼은 사용자 자산에 대한 데이터를 저장하지 않지만 노드 간 요청을 수행하는 매체 역할을합니다. 게임 제조업체는 게임 자산에 대한 자체 데이터 구조를 유연하게 설계 할 수 있습니다. 사용자가 유통 플랫폼에서 판매 요청을하면 관련 게임 자산 (통화 또는 소품)이 잠기고 요청이 취소 될 때까지 사용할 수 없습니다. 요청에는 판매자의 메인 체인 ID와 판매 할 자산의 내용이 포함됩니다. 요청이 이행되면, 시스템은 자산의 소유권을 자동으로 변경하고 구매자가 지불 한 자산을 판매자에게 양도해야합니다. 그러면 전체 순환 요청이 완료됩니다.

자산 교환이 시작되면 판매 또는 구매는 요청 형식으로 유통 플랫폼에 제출되어야합니다. 자산 양도 및 소유권 변경은 일회성 불가분의 작업으로 간주됩니다. 다시 말해, 양측의 행동은 합의에 의해 인식되어야한다. 메인 체인 블록이 한 당사자의 자산 변경을 인식하지 못하면 전체 거래가 롤백됩니다. 즉, 교환을 통한 자산 소유권 변경 또는 자산 양도는 한 번의 거래 내에서 포장되어야합니다. 두 행위의 상태는 일관되어야한다. 거래가 정상적으로 완료되면 체인을 확인하기 위해 고유 한 거래 ID를 사용할 수 있습니다.
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/099cf1e-d95ac55-_1.png",
        "d95ac55-_1.png",
        939,
        277,
        "#dde5f1"
      ],
      "caption": "3-2-9 원자 거래 상태 결정"
    }
  ]
}
[/block]
## BCX Testnet : 고성능 블록 체인 및 고속 계약 가상 머신
Cocos-BCX는 동시 작업 처리에 능숙합니다.

현재 온라인 게임의 대부분에서 사용자 규모가 특정 수준에 도달하면 서버는 짧은 시간 내에 많은 양의 데이터를 처리해야하므로 기존 Ethereum 네트워크에서는 불가능합니다.

이론적으로 Cocos-BCX의 개선 된 DPoS 합의는 최대 100,000 TPS의 처리량을 허용합니다. 합리적인 데이터 관리 모드에서 동시 작업 처리는 기존 게임의 개발 및 정상 실행을 지원하기에 충분하며 플랫폼에서 대형 온라인 게임의 기본 운영 요구를 충족하며 기존 중앙 집중식 게임과 거의 동일한 게임 경험을 보장합니다. .

대규모 온라인 게임은 DNF의 60 만 명의 온라인 사용자 기록과 Steam의 1,420 만 명의 사람 중 한 명으로 입증 된 바와 같이 데이터 상호 작용에서 상당히 높은 빈도를 의미합니다. 모든 온라인 사용자의 데이터 제출이 합의 신청으로 간주되는 경우 Cocos-BCX의 최대 처리량은 이러한 규모의 요청을 지원할 수 없습니다. 따라서 개발 팀은 감시 속도에 따라 다양한 위임 템플릿을 설계하므로 단일 대의원이 모든 런타임 게임을 동시에 감시하고 처리 할 필요는 없지만 동일한 유형의 여러 게임을 감시하고 계산하는 데 집중할 수 있습니다. 또한 템플릿 아래에서 다른 게임의 데이터 또는 증인 제출은 비동기 적입니다. 각 게임은 적절한 위임 템플릿을 선택합니다. 비동기 템플릿 아래의 데이터는 온 체인 데이터베이스 서비스를 통해 검증됩니다. 즉, 사용자는 체인에서 데이터를 검증, 저장 및 확보합니다. 이 프로세스는 대규모 게임의 플레이어 데이터 작업을 지원할만큼 효율적입니다.
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/8d17143-a6252a2-_1.png",
        "a6252a2-_1.png",
        939,
        406,
        "#eeeeee"
      ],
      "caption": "3-2-10 Cocos-BCX 계약"
    }
  ]
}
[/block]
계약은 환경의 기본 알고리즘 (컴파일러 알고리즘)에 따라 예약 된 작업을 수행하는 시스템 참가자뿐만 아니라 자동으로 실행되는 프로그램의 한 부분입니다. 계약은 입력 및 출력을 정의하고, 값을 받고 저장하며 정보와 값을 보낼 수 있습니다. 스마트 계약은 "신뢰할 수없는 원칙"으로 설계되었습니다. 모든 노드는 서로 신뢰할 수 없다고 생각합니다. 분산 스토리지를 특징으로하는 블록 체인의 각 노드는 동일한 계약 실행 코드를 유지합니다. 실행 결과는 전체 네트워크의 컴퓨팅 능력에 의해 목격됩니다. 그들이 인정되는지 여부는 모두 투표로 결정됩니다. Cocos-BCX 스마트 계약은 증인 위임의 정의를 지원합니다.

Cocos-BCX는 계약 실행 효율성이 사용자에게 건전한 게임 경험을 제공 할 수 있도록 온 체인 게임용 LUA를 기반으로하는 고속 계약 가상 머신 체계를 제공합니다. 기존 라이벌과는 달리이 스킴은 맞춤형 및 최적화 된 런타임 환경 및 실행 효율성뿐만 아니라 SDK와 동일한 언어 및 API 시스템, 체인 및 게임 실행 환경을위한 상호 운용 인터페이스를 특징으로합니다. 이는 환경의 단조 로움과 블록 체인 계약의 유연성 및 사용자 지정 문제를 해결합니다. 스마트 계약의 사용은 통화에 대한 설명을 넘어 기본 알고리즘, 설정, 단위, 장면 및지도를 포함하여 게임과 직접 관련된 콘텐츠에 적용됩니다. 개선 된 가상 머신은보다 복잡하고 유연한 계약 양식을 지원할뿐만 아니라 스마트 계약의 실행 효율성을 크게 향상시킵니다.


## 블록체인 게임을 위한 분산원장 시스템의 향상

온 체인 게임의 최종 형태는 전체 게임 로직의 온 체인 (on-chain) 구현입니다. 그러나 현재 블록 체인 기술이 전체 게임을로드하는 임계 값을 충족시킬 수 없으므로 게임 알고리즘을 블록 체인에서 마이그레이션하기 전에 몇 가지 주요 문제를 해결해야합니다.
 노드 데이터 동기화 비용 및 볼륨
스마트 계약은 전체 노드에서만 실행할 수 있습니다. 그리고 사용자가 방대한 시스템 리소스, 네트워킹 및 동기화 시간이 필요한 노드를 호스트하는 것은 실용적이지 않습니다.
 블록 크기를 초과하는 알고리즘 코드
계약이 블록 체인에서 완전한 게임 로직을 구현하려면 전체 백엔드 로직이 필요합니다. 알고리즘 스마트 계약의 크기는 특히 게임 논리가 복잡한 경우 시스템 블록 크기보다 클 수 있습니다. 그러나 현재 블록 체인 기술을 사용하면 블록이 보유 할 수없는 계약은 결코 작동하지 않으며 결과를 얻지 못합니다.
 스마트 계약의 지속적인 실행
블록 체인에서 실행되는 전체 게임 로직은 게임이 끝나기 전에 스마트 계약을 지속적으로 실행하는 것을 의미합니다. 이는 교차 블록 실행이며, 게임 알고리즘은 현재 블록 체인 기술로는 아직 사용할 수없는 블록 간격 이상의 시간 동안 지속적으로 실행될 수 있습니다.
 트랜잭션 실행 지연
블록 체인에서 실행되는 전체 게임은 또한 게임의 모든 가능한 실행이 고속 응답을 포함하여 블록 체인에서 처리됨을 의미합니다. 기존 블록 체인의 트랜잭션 응답은 시간 간격에 따른 블록 생성 동작에 따라 달라지며, 가장 빠른 확인도 블록 생성주기에 의해 제한되므로 게임 계약이 트랜잭션에 즉시 응답해야하는 필요성을 충족시키기가 어렵습니다.
 무작위 합의에 접근 할 수 없음
온 체인 랜덤 성은 공개 스마트 계약으로 설명되며, 계약 작업에 다른 노드 노이즈를 추가하여 타사에서 계산할 수없는 임의의 결과를 생성해야합니다. 그러나 다른 노드의 노이즈는 다를 수 있습니다. 즉, 다른 노드는 임의성이 올바른지 여부를 검증하기 위해 계약을 다시 실행할 수 없으므로 궁극적으로 합의에 실패합니다.
 온 체인 타이머 및 하트 비트와 같은 중요한 기능의 타당성
예약 또는 조건부 스마트 계약을 실행하려면 동기화 보안 요구 사항과 함께 타이머 및 하트 비트가 필요합니다. 현재 이러한 빌딩 블록에 대한 솔루션이 없습니다.
 디지털 자산 당국
전통적인 블록 체인 디지털 자산은 계약 데이터 영역에 기록되며 자산은 계약과 분리 할 수 ​​없습니다. 따라서 계약 소유자는 디지털 자산 데이터를 수정할 권한이있는 자산 소유자의 이익을 손상시킬 수 있습니다.

따라서 CocosChain은 기존 블록 체인을 실질적으로 개선하는 이러한 예비 설계 및 기능을 제안합니다.
 노드에서의 데이터 볼륨 및 동기화 시간 감소;
 구획화 된 합의 처리에 대한 구문 지원;
 스마트 계약의 지속적인 실행;
 이벤트 실행에 대한 최소 대기 시간;
 온 체인의 신뢰할 수있는 무작위성;
 온 체인 타이머 및 하트 비트;
 비균질 디지털 자산 데이터 구조에 권한이 추가되었습니다.


** 라이트 노드 **

Cocos-BCX에서 라이트 노드는 기본적으로
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/f682aac-fc1d209-_1.png",
        "fc1d209-_1.png",
        939,
        935,
        "#f2f3f4"
      ],
      "caption": "3-2-11 라이트 노드 및 비동기 스마트 계약 실행"
    }
  ]
}
[/block]
전체 계약이 로컬에서 실행됩니다. 합의가 필요한 부분을 실행하기 위해 합의 방법은 구문 우선 순위 식별자를 기반으로 결정됩니다. 다른 우선 순위는 다른 합의 단계를 요구합니다. 게임 계약의 실행이 더 매끄럽고 블록 대기 가능성이 적고 대기 시간이 짧습니다.

즉각적인 검증, 즉 최우선 순위로 식별 된 주요 계약의 실행 및 합의는 비동기 적입니다. 즉각적인 응답으로 식별 된 사람들의 경우, 거래가 제출되면 노드는 즉시 제출 영수증, 즉 해시 값 (Tx ID)을 반환해야합니다. 정상적인 합의로 식별 된 거래는 블록 체인의 정상적인 절차에 따라 실행되어야합니다. 합의가 필요하지 않은 것으로 밝혀진 것은 가벼운 노드에서 실행되어야합니다.

또한 합의가 필요한 계약은 하청 계약으로 분류 된 다음 실행을 위해 분배됩니다. 이 하도급 계약은 다른 노드가 결과를 정확하게 얻을 수 있도록 외부 의존없이 완전한 맥락과 디자인을 가져야합니다.

** 계약 합의 우선 순위 **

Cocos-BCX는 빠른 응답과 즉각적인 확인이 필요한 거래를 포함하여 게임에서 합의가 필요한 모든 거래를 처리합니다. 전통적인 블록 체인의 트랜잭션 응답은 블록 생산에 달려 있으며, 가장 빠른 확인은 블록 생산주기에 의해 제한되기 때문에 게임 계약이 트랜잭션을 즉시 승인 할 필요성을 충족시키기가 어렵습니다.

트랜잭션의 신속한 비동기 검증
[그림 3-2-12]에 예시 된 바와 같이, 선임 합의 작업은 마크 업, 추출 및 실행을 위해 노드로 브로드 캐스트됩니다. 블록 생산자는 노드로부터 결과를 받고 풀링합니다. 결과 수가 특정 임계 값에 도달하면 블록 생산자는 이러한 작업을 확인하고이를 블록 캐시에 씁니다.
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/795e395-14a87a8-_1.png",
        "14a87a8-_1.png",
        940,
        1022,
        "#ecf1f3"
      ],
      "caption": "3-2-12 동시 작업 처리"
    }
  ]
}
[/block]
따라서 노드는 트랜잭션을 즉시 제출, 처리 및 브로드 캐스트하고 블록 생성 및 트랜잭션 실행은 비 동기화되어 신속한 비동기 유효성 검사를 수행합니다.

 즉각적인 반응
Cocos-BCX 설계에서, 즉각적인 응답으로 식별 된 계약의 경우, 사용자가 트랜잭션 요청을 노드에 보낼 때 노드는 즉시 네트워크에이를 브로드 캐스트하고 사용자에게 해시 값을 반환해야합니다. 디자인을 사용하면 최종 레코드 기간이 기존 디자인과 크게 다르지 않지만 트랜잭션에 대한 응답은 거의 지연되지 않습니다. 노드는 즉시 거래를 제출해야하므로 응답 속도가 크게 향상됩니다.

또한 해시 값은 사용자에게 거래 상태를 알려야합니다. 한편, 거래에 대한 정보는 거래 이력 데이터 시트로 업데이트되고 응답에 대한 콜백을 받기 위해 거래가 확인되고 사용될 때까지 기다릴 필요가없는 사용자에게 동적으로 푸시됩니다. Ethereum의 해시 추적과 관련하여 사용자에게 동적으로 트랜잭션을 푸시하는 메커니즘을 추가했습니다.

** 최소 거래 대기 시간 **

기존 블록 체인은 노드가 블록에서 데이터를 수신, 실행, 검증 및 기록한 후 작업 결과를 확인합니다. 제출시 작업이 보류되고 다음 블록 생산주기에서 실행되어 시스템 대기 시간이 발생합니다.

 우선 합의
Cocos-BCX는 거래를위한 구문 우선 순위 식별자와 함께 제공됩니다. 트랜잭션이 즉시 유효성 검사로 식별되면 노드는 즉시 트랜잭션을 제출, 처리 및 브로드 캐스트합니다. 신속한 비동기 유효성 검사를 위해 블록 생성 및 트랜잭션 실행이 비 동기화됩니다. 즉각적인 대응이 또 다른 합의 우선 순위입니다. 이를 통해 트랜잭션에 대한 응답이 거의 지연되지 않습니다. 노드는 즉시 트랜잭션을 제출하므로 응답 속도가 크게 향상됩니다.

 파티션 된 증인
Cocos-BCX는 노드 활용률과 처리 효율성을 높이기 위해 델리게이트 감시를 기반으로 분할 된 감시 설계를 제안합니다. 즉, 일부 노드는 특정 유형의 계약 요청 처리에 중점을 둡니다. 디자인은 [그림 3-2-13]과 같이 작동합니다.
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/9f63f3b-0f2e3cb-_1.png",
        "0f2e3cb-_1.png",
        939,
        416,
        "#f4f3f3"
      ],
      "caption": "3-2-13 Cocos Chain의 분할 합의 설계"
    }
  ]
}
[/block]
게임 산업에서 구획화 된 감시는 요청 유형에 따라 관련 노드의 처리 기능을 최적화 할 수 있습니다. 예를 들어, 부동 소수점 연산에 대한 중앙 집중식 요청의 경우 코어 해싱 성능을 강화해야합니다. 데이터 구조 처리에 대한 중앙 집중식 요청의 경우 스토리지 IO 기능이 향상되어야합니다. 이러한 방식으로 전반적인 효율성과 이점이 최적화됩니다.

** 델리게이트 유형 트랜잭션 메커니즘 **

델리게이트 유형 트랜잭션은 주로 임의의 트랜잭션을 다루고 다른 노드에서 실행될 때 다른 결과를 생성합니다 (예 : 임의의 숫자 생성). 그러나이 유형은 비 개인 데이터와 관련된 트랜잭션 요청으로 제한��니다. 합의 식별자를 사용하여 트랜잭션을 처리 할 노드 유형을 지정하여 합의에 참여하는 노드 클러스터 (노드 그룹)의 이름을 정의 할 수 있습니다. 하나의 노드 만 필요한 경우 (N = 1) 지정된 노드 클러스터는 클러스터 내에서 하나의 온라인 노드를 무작위로 선택하여 트랜잭션을 처리합니다 (예 : 랜덤 이벤트 처리). 하나 이상의 위임 된 노드 (N> 1) 또는 하나의 클러스터가있는 경우 지정된 클러스터 내에 여러 노드가 분산되어 트랜잭션을 처리해야합니다. 신뢰할 수있는 실행 환경 검증을 통과 한 델리게이트는 위임 된 트랜잭션을 수신하면 트랜잭션의 실행 가능성을 검증하고 위임을 실행하며 완료시 트랜잭션 결과를 암호화하여 압축하여 체인에 브로드 캐스트합니다.

위임 된 노드 클러스터의 이름을 정의하는 디자인은 두 가지 이유로 채택됩니다. 먼저, 보안을 보장하기 위해 위임 된 노드의 이름 만 정의되고 트랜잭션을 처리하기 위해 클러스터 내에서 노드를 임의로 선택합니다. 대리인은 특정 위임 된 노드를 모르므로 부정 행위를 방지 할 수 있습니다. 둘째, 지정된 노드 클러스터는 런타임 안정성을 보장하기 위해 트랜잭션이 온라인 상태 인 노드에 분산되도록합니다.
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/5b73190-931799b-_1.png",
        "931799b-_1.png",
        939,
        634,
        "#f6f5f6"
      ],
      "caption": "3-2-14 델리게이트-타입 구획화된 합의"
    }
  ]
}
[/block]
** 체인내 신뢰 랜덤 프로세스 구현 **

외부 랜덤 성은 랜덤 프로세스의 불확실성이 블록 체인 시스템 외부에서 발생하는 반면 내부 랜덤은 반대입니다. 외부 랜덤 성은 블록 체인 시스템이 랜덤 팩터 생성 프로세스를 신뢰할 수 있음을 보증하지 않습니다. 따라서 블록 체인 시스템에서 합리적인 무작위성을 달성하는 것은 실제로 무작위 프로세스 및 결과의 신뢰성을 보장하는 것입니다.

 무작위 프로세스의 실행을 실제로 완료 한 노드는 정보의이 부분을 부정 행위로 피하기 위해 무작위 정보의 시나리오와 객체에 액세스 할 수 없어야합니다.
 임의의 프로세스는 호출 비즈니스 행동이 완료되기 전에 블록 체인에 공개되어서는 안되며, 따라서 임의의 선전 성으로 인해 진행중인 비즈니스가 공정성을 잃지 않도록합니다 (예 : 집주인 라운드에서 각 게이머 카드의 구성).
 내부 무작위성으로 인해 BP / 개발자가 부정 행위를 방지 할 수 있어야합니다.

현재 Cocos-BCX는 신뢰할 수있는 온 체인 랜덤 성을 성공적으로 구현했으며, 계약 개발자가 인터페이스를 통해 랜덤 성을 호출 할 수 있습니다. 일반적인 개발 방법으로 계약의 임의 함수를 호출하면 내부 소스 임의 데이터를 얻을 수 있습니다.
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/a1fd003-5d97807-_1.png",
        "5d97807-_1.png",
        940,
        200,
        "#f0f1f2"
      ],
      "caption": "3-2-15 온-체인 신뢰 랜덤 프로세스"
    }
  ]
}
[/block]
** 체인간 신뢰 랜덤 프로세스 **

블록 체인의 게임 알고리즘이 실제 가치를 지니고 있는지 여부는 온 체인 랜덤 성과 관련이 있습니다. 연구에 따르면 완전한 온 체인 랜덤 성을 위해서는 하나의 핵심 문제를 해결해야합니다. 온 체인 랜덤 알고리즘은 스마트 계약으로 설명되며 계약 프로세스는 공개됩니다. 타사에서 파악할 수없는 임의의 결과가 생성되는 경우 계약 실행 중 프로세스의 입력 노드에서 노이즈가 발생해야합니다. 그러나 다른 노드의 노이즈는 다를 수 있습니다. 즉, 다른 노드가 계약을 다시 실행하여 임의성이 올바른지 여부를 확인하여 합의에 실패 할 수 있습니다.

이 문제를 해결하기 위해 세 가지 가능한 솔루션을 제안했습니다.

솔루션 Ⅰ
 하나 이상의 랜덤 데이터 풀이 블록 체인의 동적 데이터 영역에 예약되어 있습니다. 블록 생산자는 임의의 결과를 블록의 암호화 된 데이터 세그먼트로 랩핑하고 폐쇄 소스 암호화 코드를 해제합니다. 이 경우, 모든 노드는 데이터가 읽기 및 쓰기 측과 파이프 형태이고 알고리즘 및 특징에 따라 읽기 및 쓰기 측에 액세스 할 수있는 동일한 랜덤 데이터 풀 세트를 가져야합니다. 아웃.

 트랜잭션 처리는 블록 체인의 모든 노드에서 일관되므로 응용 프로그램은 응용 프로그램 중 임의의 데이터 풀에서 임의의 결과를 읽을 수 있습니다. 이러한 생성 및 배포 메커니즘에서 프로세스 및 결과의 보안은 블록 체인 네트워크의 요구 사항을 충족합니다.

 모든 액세스 (읽기 및 쓰기)로 인해 임의 데이터 풀이 되돌릴 수 없습니다.
 임의의 데이터 쓰기는 비공개 소스 동적 암호화 라이브러리로 완료해야합니다.
 랜덤 데이터 생성기는 랜덤 결과가 랜덤 데이터 풀에서 어디에 위치하고 랜덤 프로세스를 누가 사용해야하는지 알 수 없습니다.

이 솔루션은 체인 네트워크가 트랜잭션 처리 순서로 일관성을 나타내는 장면에 적용 할 수 있습니다. 예를 들어, RPG 게임에서 플레이어는 무작위 소품을 위해 맵 전리품 상자를 엽니 다.

솔루션 Ⅱ
 위임 메커니즘을 통해 일부 트랜잭션을 처리 할 수있는 일부 신뢰할 수있는 노드 클러스터에 위임 할 수 있습니다. 클러스터는 트랜잭션을 실행하기 위해 임의로 온라인으로 신뢰할 수있는 노드를 할당합니다. 실행 후, 신뢰할 수있는 노드는 무작위 결과를 기록해야한다. 고객은 통보 또는 폴링 메커니즘을 통해 결과를 얻어야합니다.
이 솔루션은 체인 거래 위임 메커니즘을 기반으로하기 때문에 체인 변경은 솔루션 1의 변경보다 작아야합니다. 그러나 솔루션의 가능성을 보장하려면 다음 요구 사항을 충족해야합니다.

 위탁 당사자는 신뢰성을 보장하기 위해 신뢰할 수있는 실행 환경 검증을 통과해야합니다.
 대리인이 무작위성을 실행하고 결과를 발표 할 때 동일한 안전한 암호화 라이브러리를 사용해야합니다.
 암호화 된 데이터의 전송을 위해 대리인의 신원을 증명하기 위해 제로 지식 증명 또는 기타 체계를 사용해야하며 고객이 인식 할 수 있도록 제 3자가 고객이 획득 한 데이터를 위조하지 않도록해야합니다. .

이 솔루션은 여러 당사자가 참여하지만 체스 및 카드 게임의 셔플 순서와 같이 무작위 결과가 한 번에 한 번만 필요한 트랜잭션에 적용됩니다.

솔루션 Ⅲ
 현재 블록 생산자는 랜덤 트랜잭션을 수신하고, 랜덤 기능을 통해 결과를 생성하고, 랜덤 성과 결과를 암호화하고, 블록 데이터에 기록하고,이를 전체 네트워크로 전송합니다. 다른 일반 노드는 결과를 수락하고 사용하여 임의 트랜잭션에 대한 합의에 도달합니다.

이 솔루션은 임의의 결과를 위해 주사위를 던지는 것과 같이 게임의 복권 추첨에 적용됩니다.

** 타이머와 하트비트 **

거의 모든 게임과 응용 프로그램은 온라인 감지가 필요합니다. Cocos-BCX 블록 체인 게임의 경우 사용자 상태 감지 및 연속 세션에 응답하여 두 가지 개념, 즉 타이머와 하트 비트가 제시됩니다.
시간 동기화 메커니즘은 블록 체인 네트워크에서 타이머의 전제입니다. 전통적인 메커니즘은 외부 시간 신호 또는 신뢰 센터로 구축됩니다. 블록 체인의 신뢰할 수없는 논리에 따라 외부 시간 신호와 신뢰 센터에는 모두 자체 검증 할 수없는 결함이 있습니다. 따라서 온 체인 시간 동기화는 블록 체인에서만 완료 할 수 있습니다.

Cocos-BCX의 시간 동기화 솔루션은 블록 타임 스탬프와 함께 작동하여 블록 노드는 블록을 해제하는 동안 동등한 시간 동기화를 브로드 캐스트합니다. 각 노드는 블록 브로드 캐스트를 수신하면 시간 동기화 작업을 완료합니다. 결국, 전체 네트워크에 대한 시간 동기화는 한 블록 동기화주기에서 한 번 완료된다.

이러한 설계를 통해 두 가지 형식의 타이머 기술 지원이 제공됩니다.
 최소 타이밍 단위로 블록주기를 사용하면 예약 된 타이밍 목표에 따라 타이머가 작동합니다. 시간대와 같은 요인으로 인한 바이어스가 없으면 블록 타임 스탬프는 전체 네트워크의 타이밍 표준으로 간주됩니다. 타이머는 동일한 타이밍 규칙에 따라 모든 네트워크 영역 및 표준 시간대에서 정상적으로 실행될 수 있습니다.
 내부 소스 랜덤 프로세스와 유사한 메시징 메커니즘을 사용하여 위임에 의해 타이머에 필요한 매개 변수를 임의의 노드에 제출하면 노드의 구현 계층이 타이머의 초기화 및 만료 알림을 포함한 동작을 실행합니다.

하트 비트는 타이머와 유사합니다. 타임 펄스는 블록 타임 스탬프에서도 발생합니다. 하트 비트 기간 동안 노드 / 엔드는 업데이트 된 연결에 대한 정보를 제출합니다. 기간 내에 이러한 정보가 없으면 노드 / 엔드가 오프라인 상태임을 나타냅니다. 타이머 및 하트 비트는 사용자 상태 감지 및 향후 세션에 대한 응용 프로그램 기반을 제공합니다.

** 표준화된 대체 불가능한 자산 **

블록 체인은 비균질 디지털 자산 데이터 구조를 고정 및 확장 가능한 데이터 영역으로 나누고, 후자는 비균질 디지털 자산의 속성 확장을 지원하여 영역 데이터 및 데이터 포함 데이터를 포함하여 지원되는 월드 뷰 내 특정 게임 트랜잭션 데이터의 저장 영역 역할을합니다 조합 관계. 비균질의 유연한 구조의 확장 가능한 데이터 영역을 통해 게임 또는 기타 비즈니스 시나리오를 확장 할 수 있습니다. 게임이 증가함에 따라 자산이 다른 게임으로 이전 될 때 영역 데이터가 점차 추가되어 체인 운영의 효율성에 영향을줍니다. 한편, 악의적 인 데이터가 계약서에 작성되어 중복이 발생하지 않도록 자산 권한을 추가해야합니다.
 자산 소유자는 특정 영역 데이터를 삭제할 수는 있지만 수정할 수는 없습니다. 이로 인해 사용자 지정 향상 소품과 같은 부정 행위를 방지하면서 데이터 중복성을 줄일 수 있습니다.
 계약은 담당 영역 데이터 만 수정할 수 있습니다. 계약은 NH 자산의 확장 가능 데이터에 대한 모든 정보를 읽지 만 수정 권한은 현재 데이터 영역으로 제한됩니다. 예를 들어, 블록 체인 게임에서 계약은 게임 "HEROES OF THE STORM"및 "World of Warcraft"의 관련 자산 데이터를 읽는 반면 "HEROES OF THE STORM"의 "Frostmourne"무기는 실제로 차단되지 않습니다 "World of Warcraft"에서는 "cut-off"상태를 나타냅니다.

** 규칙기반 개발 도구 **

실제 게임 시나리오에서 사용자는 일부 게임의 공개 규칙을 인식하지만 게임에 참여한 후 자산을 잃는 것으로 나타났습니다. 더 이상 사용자에게 서비스를 제공하지 않으므로 개발자에게 유리하지만 사용자에게 피해를줍니다. 기존의 도구는 이러한 현상을 방지하기 위해 개발되었습니다. 게임 개발자는 블록 체인 기반 게임에 대한“확정 된 규칙을위한 디자인 도구”를 사용하여 사용자 신뢰를 향상시키기 위해 블록 체인 게임을 디자인 할 수 있습니다. 이는 스마트 계약을 사용하여 일정량의 동종 자산을 잠근 다음 잠금 해제 요구 사항, 시간 및 양을 설정하여 실현됩니다. 자산 잠금 중에 게임 코드를 수정할 수없는 유틸리티 기능을 계약 코드에 추가합니다. 자산 잠금 중에 계약 코드를 수정할 수 없으므로 게임은 초기 규칙 내에서 작동합니다.

## BP / 개발자가 부정 행위를 방지하는 Cheat-proof Transaction 인증 메커니즘
 
네트워크를 통한 트랜잭션 처리 및 통신의 핵심 노드 인 BP는 일반 노드보다 결과에 빠르게 액세스 할 수 있으므로 적시 또는 기밀 정보를 수집하는 데 우선 순위가 높습니다. 이것은 또한 부정 행위의 가능성을 나타냅니다. 예를 들어, BP는 사전에 임의의 프로세스 결과를 통보받을 수 있고 계약을 활용하여 운영 결과를 예측할 수 있습니다. 이는 공개 체인의 게임에 불공평하고 안전하지 않게 만듭니다.

본 문서에서 개발자는 체인 네트워크의 하위 수준 및 계약 개발자를 포함하여 체인 상호 작용 또는 변환을 실행할 수있는 개인 및 조직을 나타냅니다. 체인 정보를 심층적으로 분석하거나 제어 할 수 있습니다. 랜덤 프로세스 및 민감한 데이터의 정보를 불법적으로 획득하기 위해 전송 및 설계 코드에 사용될 수있는 통신 기술의 암호화 또는 은닉 된 세부 사항에 액세스하기 위해 코드를 읽을 수 있다고 믿을만한 이유가있다.

따라서 BCX에는 트랜잭션 실행, 정보 전송 및 작업을위한 메커니즘이 제공되어 BP와 개발자가 부정 행위를 방지 할 수 있습니다.

** 동적 암호화 전송 **

브로드 캐스트 중에 민감한 정보가 가로 채지고 해독되는 것을 방지하기 위해 [그림 3-2-16]과 같이 동적 암호화를 사용한 안전한 전송 모드가 BCX 체인 네트워크에 통합되었습니다.
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/19bee22-6f122ce-_1.png",
        "6f122ce-_1.png",
        939,
        530,
        "#f8f9fa"
      ],
      "caption": "3-2-16 동적 암호화를 통한 전송"
    }
  ]
}
[/block]
랜덤 시드를 예로 들어, 랜덤 시드가 생성 될 때, 생산자는 시간, 블록 높이 및 기타 노이즈 입력에 관한 동적 데이터를 사용하여 정보를 AES 키로 암호화하고 암호화 된 정보를 브로드 캐스트합니다. 모든 노드는 정보를 올바르게 해독 할 수있는 동적 키 생성을 위해 동일한 알고리즘을 공유합니다. 그러나 도청하는 제 3자는이를 수행 할 수 없으므로 전송 중에 민감한 데이터의 보안을 보장합니다.

** 사용자 정의 노드가 네트워크에 액세스하지 못하도록 방지 **

사운드 전송 보안만으로는 노드 개발자가 수신하고 해독 한 정보를 출력하도록 프로그램을 수정하는 것을 막을 수 없습니다. 따라서 [그림 3-2-17]과 같이 수정 된 노드 프로그램이 체인 네트워크에 연결되는 것을 방지하기 위해 인증 메커니즘이 통합되어 있습니다.
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/fa93233-0341def-_1.png",
        "0341def-_1.png",
        939,
        571,
        "#f9f9fa"
      ],
      "caption": "3-2-17 노드 엑세스 검증 메커니즘"
    }
  ]
}
[/block]
릴리스 전에 BCK 노드 프로그램에는 아직 버전 번호와 관련이있는 공개 소스 코드에 포함되지 않은 인증 정보가 포함됩니다. 노드가 체인 네트워크 및 다른 노드에 연결을 시도하면 후자는 체인 네트워크에 기록 된 정보와 일치하는지 확인하고 인증을 통과하지 못한 노드의 연결을 거부합니다. 이런 방식으로 수정 된 노드 프로그램에서 체인 네트워크로의 악의적 인 연결이 중지됩니다. 또한 2 차 개발자는 소스 코드의 인증 정보를 사용자 정의하여 자체 체인 네트워크를 해제 할 수 있으며, 이로 인해 비공식 코드 연결을 방지 할 수 있습니다.

** 공통 공정 변수 **

계약 자체는 Turing-complete 상태 머신 시스템이므로 고정 입력은 고정 출력을 도출하고 결과는 트랜잭션 메커니즘 하에서 동기화를 위해 전체 네트워크에 브로드 캐스트됩니다. 브로드 캐스트 정보가 일련의 동작의 중간 프로세스 인 경우 알려지지 않은 일부 프로세스 변수가 공개 될 수 있습니다. 이 문제를 해결하기 위해 [그림 3-2-18]과 같이 프로세스 변수를 숨기는 계약 실행 로직이 제시된다.

합리적인 계약 설계를 통해 민감한 데이터와 관련된 프로세스 변수는 동일한 OP에서 실행되며 실행 노드의 메모리에서 완료됩니다. 마지막에 방송되는 것은 OP 결과입니다. 이러한 방식으로 공정 변수는 노출 위험없이 기간 전체에 숨겨집니다.
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/aa604ef-27b0535-_1.png",
        "27b0535-_1.png",
        940,
        609,
        "#fafbfc"
      ],
      "caption": "3-2-18 공정 변수 은폐 메커니즘"
    }
  ]
}
[/block]
** 실행 인증을 통한 계약 메커니즘 **

악의적 인 개발자가 계약 인터페이스의 테스트 사용을 통해 계약의 가능한 출력을 예측하지 못하도록 실행 인증 메커니즘이 추가되었습니다. 구체적으로, [그림 3-2-19]와 같이 인증 된 계정 만 특정 계약 인터페이스를 실행할 수 있습니다.
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/545ca92-b1cbe57-_1.png",
        "b1cbe57-_1.png",
        939,
        526,
        "#fafafa"
      ],
      "caption": "3-2-19 실행 인증을 사용하는 계약 메커니즘"
    }
  ]
}
[/block]
계약이 실행 요청을 받으면 요청의 서명은 계약에 지정된 실행 권한에 대해 확인됩니다. 요청이 인증을 통과 한 경우에만 계약 기능이 정상적으로 실행됩니다. 그렇지 않으면, 계약자는 요청자에게 지불을 반환하지 않고 직접 종료됩니다. 이 메커니즘을 사용하면 개발자가 체인 코드와 계약, 프로세스 및 실행 원칙을 알고 있어도 특정 인터페이스를 악의적으로 사용할 수 없습니다. 이것은 계약이 실행 결과의 예측을 위해 임의로 사용되지 않도록 보장합니다.

** 민감한 프로세스 실행을 위한 내부의 신뢰할 수 있는 환경 **

보드 게임과 같이 특정 시간 동안 민감한 정보 나 작업의 경우이 구성표를 사용하면 기간 내의 실행 로직이 TEE (Trusted Execution Environment) 메커니즘으로부터 보호되어 블랙 박스 모드에서 작동 할 수 있습니다. 일반적으로 체인 네트워크는 TEE 메커니즘을 통해 정기적으로 BlackBox 환경에 도전하거나 검증하여 안정성을 보장합니다. 또한 민감한 프로세스의 실행을 위해 이들 중 임의의 것을 선택해야합니다. 실행이 완료되면 추적 가능한 기록과 결과를 온라인으로 제출하여 체인 네트워크에서 공정하고 공개적이며 투명한 기록을 보장해야합니다. [그림 3-2-20]과 같이 동작합니다.
[block:image]
{
  "images": [
    {
      "image": [
        "https://files.readme.io/8759b92-d349d17-_1.png",
        "d349d17-_1.png",
        939,
        323,
        "#f5f6f6"
      ],
      "caption": "3-2-20 민감한 프로세스의 내부 실행 메커니즘"
    }
  ]
}
[/block]
이 메커니즘은 따라서 자신의 부정 행위를 피할 블랙 박스 프로세스의 실행에 참여 개발자와 BP를 방지 할 수 있습니다. 위에서 지정한 디자인으로 COCOS-BCX는 지원하는 모든 비즈니스에 신뢰할 수 있고 신뢰할 수있는 안전한 실행 환경을 제공해야합니다.